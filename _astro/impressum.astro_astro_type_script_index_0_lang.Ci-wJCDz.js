var g={allRenderFn:!1,element:!0,event:!0,hasRenderFn:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,formAssociated:!1,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,propChangeCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,constructableCSS:!0,devTools:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!0,asyncQueue:!1,transformTagName:!1,attachStyles:!0,experimentalSlotFixes:!1},je="app",He=Object.defineProperty,Pe=(e,t)=>{for(var s in t)He(e,s,{get:t[s],enumerable:!0})},Fe="http://www.w3.org/2000/svg",De="http://www.w3.org/1999/xhtml",Ue=(e,t)=>{var s;const r=t.$cmpMeta$;Object.entries((s=r.$members$)!=null?s:{}).map(([i,[a]])=>{if(a&31||a&32){const l=e[i],o=Ce(Object.getPrototypeOf(e),i)||Object.getOwnPropertyDescriptor(e,i);o&&Object.defineProperty(e,i,{get(){return o.get.call(this)},set(c){o.set.call(this,c)},configurable:!0,enumerable:!0}),e[i]=t.$instanceValues$.has(i)?t.$instanceValues$.get(i):l}})};function Ce(e,t){for(;e;){const s=Object.getOwnPropertyDescriptor(e,t);if(s?.get)return s;e=Object.getPrototypeOf(e)}}var O=e=>{if(e.__stencil__getHostRef)return e.__stencil__getHostRef()},Be=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map,$serializerValues$:new Map};s.$onReadyPromise$=new Promise(n=>s.$onReadyResolve$=n),e["s-p"]=[],e["s-rc"]=[];const r=s;return e.__stencil__getHostRef=()=>r,t.$flags$&512&&g.state&&Ue(e,s),r},ie=(e,t)=>t in e,D=(e,t)=>(0,console.error)(e,t),B=new Map,Me=[],qe="slot-fb{display:contents}slot-fb[hidden]{display:none}",le="http://www.w3.org/1999/xlink",p=typeof window<"u"?window:{},We=p.HTMLElement||class{},S={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,r)=>e.addEventListener(t,s,r),rel:(e,t,s,r)=>e.removeEventListener(t,s,r),ce:(e,t)=>new CustomEvent(e,t)},Ie=(()=>{var e;let t=!1;try{(e=p.document)==null||e.addEventListener("e",null,Object.defineProperty({},"passive",{get(){t=!0}}))}catch{}return t})(),Ne=e=>Promise.resolve(e),Z=(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})(),G=Z?!!p.document&&Object.getOwnPropertyDescriptor(p.document.adoptedStyleSheets,"length").writable:!1,Q=!1,oe=[],Se=[],Ge=(e,t)=>s=>{e.push(s),Q||(Q=!0,t&&S.$flags$&4?V(X):S.raf(X))},ae=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){D(s)}e.length=0},X=()=>{ae(oe),ae(Se),(Q=oe.length>0)&&S.raf(X)},V=e=>Ne().then(e),Qe=Ge(Se,!0),Xe=e=>e!=null&&e!==void 0,ee=e=>(e=typeof e,e==="object"||e==="function");function Ke(e){var t,s,r;return(r=(s=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:s.getAttribute("content"))!=null?r:void 0}var Ye=e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),Je={};Pe(Je,{err:()=>_e,map:()=>Ze,ok:()=>K,unwrap:()=>Ve,unwrapErr:()=>et});var K=e=>({isOk:!0,isErr:!1,value:e}),_e=e=>({isOk:!1,isErr:!0,value:e});function Ze(e,t){if(e.isOk){const s=t(e.value);return s instanceof Promise?s.then(r=>K(r)):K(s)}if(e.isErr){const s=e.value;return _e(s)}throw"should never get here"}var Ve=e=>{if(e.isOk)return e.value;throw e.value},et=e=>{if(e.isErr)return e.value;throw e.value};var j;function tt(e){var t;const s=this.attachShadow({mode:"open",delegatesFocus:!!(e.$flags$&16)});j===void 0&&(j=(t=void 0)!=null?t:null),j&&(G?s.adoptedStyleSheets.push(j):s.adoptedStyleSheets=[...s.adoptedStyleSheets,j])}var ke=e=>{const t=$e(e,"childNodes");e.tagName&&e.tagName.includes("-")&&e["s-cr"]&&e.tagName!=="SLOT-FB"&&be(t,e.tagName).forEach(r=>{r.nodeType===1&&r.tagName==="SLOT-FB"&&(rt(r,te(r),!1).length?r.hidden=!0:r.hidden=!1)});let s=0;for(s=0;s<t.length;s++){const r=t[s];r.nodeType===1&&$e(r,"childNodes").length&&ke(r)}},st=e=>{const t=[];for(let s=0;s<e.length;s++){const r=e[s]["s-nr"]||void 0;r&&r.isConnected&&t.push(r)}return t};function be(e,t,s){let r=0,n=[],i;for(;r<e.length;r++)i=e[r],i["s-sr"]&&(!t||i["s-hn"]===t)&&s===void 0&&n.push(i),n=[...n,...be(i.childNodes,t,s)];return n}var rt=(e,t,s=!0)=>{const r=[];(s&&e["s-sr"]||!e["s-sr"])&&r.push(e);let n=e;for(;n=n.nextSibling;)te(n)===t&&(s||!n["s-sr"])&&r.push(n);return r},ce=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",te=e=>typeof e["s-sn"]=="string"?e["s-sn"]:e.nodeType===1&&e.getAttribute("slot")||void 0;function nt(e){if(e.assignedElements||e.assignedNodes||!e["s-sr"])return;const t=s=>(function(r){const n=[],i=this["s-sn"];r?.flatten&&console.error(`
          Flattening is not supported for Stencil non-shadow slots.
          You can use \`.childNodes\` to nested slot fallback content.
          If you have a particular use case, please open an issue on the Stencil repo.
        `);const a=this["s-cr"].parentElement;return(a.__childNodes?a.childNodes:st(a.childNodes)).forEach(o=>{i===te(o)&&n.push(o)}),s?n.filter(o=>o.nodeType===1):n}).bind(e);e.assignedElements=t(!0),e.assignedNodes=t(!1)}function $e(e,t){if("__"+t in e){const s=e["__"+t];return typeof s!="function"?s:s.bind(e)}else return typeof e[t]!="function"?e[t]:e[t].bind(e)}var z=(e,t="")=>()=>{},R=new WeakMap,it=(e,t,s)=>{let r=B.get(e);Z&&s?(r=r||new CSSStyleSheet,typeof r=="string"?r=t:r.replaceSync(t)):r=t,B.set(e,r)},lt=(e,t,s)=>{var r;const n=me(t,s),i=B.get(n);if(!p.document)return n;if(e=e.nodeType===11?e:p.document,i)if(typeof i=="string"){e=e.head||e;let a=R.get(e),l;if(a||R.set(e,a=new Set),!a.has(n)){{l=p.document.createElement("style"),l.innerHTML=i;const o=(r=S.$nonce$)!=null?r:Ke(p.document);if(o!=null&&l.setAttribute("nonce",o),!(t.$flags$&1))if(e.nodeName==="HEAD"){const c=e.querySelectorAll("link[rel=preconnect]"),f=c.length>0?c[c.length-1].nextSibling:e.querySelector("style");e.insertBefore(l,f?.parentNode===e?f:null)}else if("host"in e)if(Z){const c=new CSSStyleSheet;c.replaceSync(i),G?e.adoptedStyleSheets.unshift(c):e.adoptedStyleSheets=[c,...e.adoptedStyleSheets]}else{const c=e.querySelector("style");c?c.innerHTML=i+c.innerHTML:e.prepend(l)}else e.append(l);t.$flags$&1&&e.insertBefore(l,null)}t.$flags$&4&&(l.innerHTML+=qe),a&&a.add(n)}}else e.adoptedStyleSheets.includes(i)||(G?e.adoptedStyleSheets.push(i):e.adoptedStyleSheets=[...e.adoptedStyleSheets,i]);return n},ot=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,r=t.$flags$,n=z("attachStyles",t.$tagName$),i=lt(s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);r&10&&(s["s-sc"]=i,s.classList.add(i+"-h")),n()},me=(e,t)=>"sc-"+(t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$),M=(e,t,...s)=>{let r=null,n=null,i=null,a=!1,l=!1;const o=[],c=u=>{for(let $=0;$<u.length;$++)r=u[$],Array.isArray(r)?c(r):r!=null&&typeof r!="boolean"&&((a=typeof e!="function"&&!ee(r))&&(r=String(r)),a&&l?o[o.length-1].$text$+=r:o.push(a?q(null,r):r),l=a)};if(c(s),t){t.key&&(n=t.key),t.name&&(i=t.name);{const u=t.className||t.class;u&&(t.class=typeof u!="object"?u:Object.keys(u).filter($=>u[$]).join(" "))}}if(typeof e=="function")return e(t===null?{}:t,o,$t);const f=q(e,null);return f.$attrs$=t,o.length>0&&(f.$children$=o),f.$key$=n,f.$name$=i,f},q=(e,t)=>{const s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return s.$attrs$=null,s.$key$=null,s.$name$=null,s},at={},ct=e=>e&&e.$tag$===at,$t={forEach:(e,t)=>e.map(fe).forEach(t),map:(e,t)=>e.map(fe).map(t).map(ft)},fe=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),ft=e=>{if(typeof e.vtag=="function"){const s={...e.vattrs};return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),M(e.vtag,s,...e.vchildren||[])}const t=q(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},se=e=>{const t=Ye(e);return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`,"g")};se("::slotted");se(":host");se(":host-context");var dt=e=>Me.map(t=>t(e)).find(t=>!!t),Ee=(e,t,s)=>e!=null&&!ee(e)?t&4?e==="false"?!1:e===""||!!e:t&2?typeof e=="string"?parseFloat(e):typeof e=="number"?e:NaN:t&1?String(e):e:e,ut=(e,t,s)=>{const r=S.ce(t,s);return e.dispatchEvent(r),r},de=(e,t,s,r,n,i,a)=>{if(s===r)return;let l=ie(e,t),o=t.toLowerCase();if(t==="class"){const c=e.classList,f=ue(s);let u=ue(r);c.remove(...f.filter($=>$&&!u.includes($))),c.add(...u.filter($=>$&&!f.includes($)))}else if(t==="style"){for(const c in s)(!r||r[c]==null)&&(c.includes("-")?e.style.removeProperty(c):e.style[c]="");for(const c in r)(!s||r[c]!==s[c])&&(c.includes("-")?e.style.setProperty(c,r[c]):e.style[c]=r[c])}else if(t!=="key")if(t==="ref")r&&r(e);else if(!e.__lookupSetter__(t)&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"?t=t.slice(3):ie(p,o)?t=o.slice(2):t=o[2]+t.slice(3),s||r){const c=t.endsWith(xe);t=t.replace(pt,""),s&&S.rel(e,t,s,c),r&&S.ael(e,t,r,c)}}else{const c=ee(r);if((l||c&&r!==null)&&!n)try{if(e.tagName.includes("-"))e[t]!==r&&(e[t]=r);else{const u=r??"";t==="list"?l=!1:(s==null||e[t]!=u)&&(typeof e.__lookupSetter__(t)=="function"?e[t]=u:e.setAttribute(t,u))}}catch{}let f=!1;o!==(o=o.replace(/^xlink\:?/,""))&&(t=o,f=!0),r==null||r===!1?(r!==!1||e.getAttribute(t)==="")&&(f?e.removeAttributeNS(le,t):e.removeAttribute(t)):(!l||i&4||n)&&!c&&e.nodeType===1&&(r=r===!0?"":r,f?e.setAttributeNS(le,t,r):e.setAttribute(t,r))}},ht=/\s/,ue=e=>(typeof e=="object"&&e&&"baseVal"in e&&(e=e.baseVal),!e||typeof e!="string"?[]:e.split(ht)),xe="Capture",pt=new RegExp(xe+"$"),Y=(e,t,s,r)=>{const n=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,i=e&&e.$attrs$||{},a=t.$attrs$||{};for(const l of he(Object.keys(i)))l in a||de(n,l,i[l],void 0,s,t.$flags$);for(const l of he(Object.keys(a)))de(n,l,i[l],a[l],s,t.$flags$)};function he(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var C,W,H,J=!1,I=!1,re=!1,k=!1,N=(e,t,s)=>{var r;const n=t.$children$[s];let i=0,a,l,o;if(J||(re=!0,n.$tag$==="slot"&&(n.$flags$|=n.$children$?2:1)),n.$text$!==null)a=n.$elm$=p.document.createTextNode(n.$text$);else if(n.$flags$&1)a=n.$elm$=p.document.createTextNode(""),Y(null,n,k);else{if(k||(k=n.$tag$==="svg"),!p.document)throw new Error("You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.");if(a=n.$elm$=p.document.createElementNS(k?Fe:De,!J&&g.slotRelocation&&n.$flags$&2?"slot-fb":n.$tag$),k&&n.$tag$==="foreignObject"&&(k=!1),Y(null,n,k),Xe(C)&&a["s-si"]!==C&&a.classList.add(a["s-si"]=C),n.$children$)for(i=0;i<n.$children$.length;++i)l=N(e,n,i),l&&a.appendChild(l);n.$tag$==="svg"?k=!1:a.tagName==="foreignObject"&&(k=!0)}return a["s-hn"]=H,n.$flags$&3&&(a["s-sr"]=!0,a["s-cr"]=W,a["s-sn"]=n.$name$||"",a["s-rf"]=(r=n.$attrs$)==null?void 0:r.ref,nt(a),o=e&&e.$children$&&e.$children$[s],o&&o.$tag$===n.$tag$&&e.$elm$&&P(e.$elm$,!1),Ae(W,a,t.$elm$,e?.$elm$)),a},P=(e,t)=>{S.$flags$|=1;const s=Array.from(e.__childNodes||e.childNodes);e["s-sr"]&&g.experimentalSlotFixes;for(let r=s.length-1;r>=0;r--){const n=s[r];n["s-hn"]!==H&&n["s-ol"]&&(x(F(n).parentNode,n,F(n)),n["s-ol"].remove(),n["s-ol"]=void 0,n["s-sh"]=void 0,re=!0),t&&P(n,t)}S.$flags$&=-2},Te=(e,t,s,r,n,i)=>{let a=e["s-cr"]&&e["s-cr"].parentNode||e,l;for(a.shadowRoot&&a.tagName===H&&(a=a.shadowRoot);n<=i;++n)r[n]&&(l=N(null,s,n),l&&(r[n].$elm$=l,x(a,l,F(t))))},Le=(e,t,s)=>{for(let r=t;r<=s;++r){const n=e[r];if(n){const i=n.$elm$;ze(n),i&&(I=!0,i["s-ol"]?i["s-ol"].remove():P(i,!0),i.remove())}}},gt=(e,t,s,r,n=!1)=>{let i=0,a=0,l=0,o=0,c=t.length-1,f=t[0],u=t[c],$=r.length-1,h=r[0],d=r[$],v,y;for(;i<=c&&a<=$;)if(f==null)f=t[++i];else if(u==null)u=t[--c];else if(h==null)h=r[++a];else if(d==null)d=r[--$];else if(U(f,h,n))A(f,h,n),f=t[++i],h=r[++a];else if(U(u,d,n))A(u,d,n),u=t[--c],d=r[--$];else if(U(f,d,n))(f.$tag$==="slot"||d.$tag$==="slot")&&P(f.$elm$.parentNode,!1),A(f,d,n),x(e,f.$elm$,u.$elm$.nextSibling),f=t[++i],d=r[--$];else if(U(u,h,n))(f.$tag$==="slot"||d.$tag$==="slot")&&P(u.$elm$.parentNode,!1),A(u,h,n),x(e,u.$elm$,f.$elm$),u=t[--c],h=r[++a];else{for(l=-1,o=i;o<=c;++o)if(t[o]&&t[o].$key$!==null&&t[o].$key$===h.$key$){l=o;break}l>=0?(y=t[l],y.$tag$!==h.$tag$?v=N(t&&t[a],s,l):(A(y,h,n),t[l]=void 0,v=y.$elm$),h=r[++a]):(v=N(t&&t[a],s,a),h=r[++a]),v&&x(F(f.$elm$).parentNode,v,F(f.$elm$))}i>c?Te(e,r[$+1]==null?null:r[$+1].$elm$,s,r,a,$):a>$&&Le(t,i,c)},U=(e,t,s=!1)=>e.$tag$===t.$tag$?e.$tag$==="slot"?e.$name$===t.$name$:s?(s&&!e.$key$&&t.$key$&&(e.$key$=t.$key$),!0):e.$key$===t.$key$:!1,F=e=>e&&e["s-ol"]||e,A=(e,t,s=!1)=>{const r=t.$elm$=e.$elm$,n=e.$children$,i=t.$children$,a=t.$tag$,l=t.$text$;let o;l===null?(k=a==="svg"?!0:a==="foreignObject"?!1:k,Y(e,t,k),n!==null&&i!==null?gt(r,n,t,i,s):i!==null?(e.$text$!==null&&(r.textContent=""),Te(r,null,t,i,0,i.length-1)):!s&&g.updatable&&n!==null&&Le(n,0,n.length-1),k&&a==="svg"&&(k=!1)):(o=r["s-cr"])?o.parentNode.textContent=l:e.$text$!==l&&(r.data=l)},m=[],Oe=e=>{let t,s,r;const n=e.__childNodes||e.childNodes;for(const i of n){if(i["s-sr"]&&(t=i["s-cr"])&&t.parentNode){s=t.parentNode.__childNodes||t.parentNode.childNodes;const a=i["s-sn"];for(r=s.length-1;r>=0;r--)if(t=s[r],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==i["s-hn"])if(ce(t,a)){let l=m.find(o=>o.$nodeToRelocate$===t);I=!0,t["s-sn"]=t["s-sn"]||a,l?(l.$nodeToRelocate$["s-sh"]=i["s-hn"],l.$slotRefNode$=i):(t["s-sh"]=i["s-hn"],m.push({$slotRefNode$:i,$nodeToRelocate$:t})),t["s-sr"]&&m.map(o=>{ce(o.$nodeToRelocate$,t["s-sn"])&&(l=m.find(c=>c.$nodeToRelocate$===t),l&&!o.$slotRefNode$&&(o.$slotRefNode$=l.$slotRefNode$))})}else m.some(l=>l.$nodeToRelocate$===t)||m.push({$nodeToRelocate$:t})}i.nodeType===1&&Oe(i)}},ze=e=>{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(ze)},x=(e,t,s)=>(typeof t["s-sn"]=="string"&&t["s-sr"]&&t["s-cr"]&&Ae(t["s-cr"],t,e,t.parentElement),e?.insertBefore(t,s));function Ae(e,t,s,r){var n,i;let a;if(e&&typeof t["s-sn"]=="string"&&t["s-sr"]&&e.parentNode&&e.parentNode["s-sc"]&&(a=t["s-si"]||e.parentNode["s-sc"])){const l=t["s-sn"],o=t["s-hn"];if((n=s.classList)==null||n.add(a+"-s"),r&&((i=r.classList)!=null&&i.contains(a+"-s"))){let c=(r.__childNodes||r.childNodes)[0],f=!1;for(;c;){if(c["s-sn"]!==l&&c["s-hn"]===o&&c["s-sr"]){f=!0;break}c=c.nextSibling}f||r.classList.remove(a+"-s")}}}var vt=(e,t,s=!1)=>{var r,n,i,a,l;const o=e.$hostElement$,c=e.$cmpMeta$,f=e.$vnode$||q(null,null),$=ct(t)?t:M(null,null,t);if(H=o.tagName,c.$attrsToReflect$&&($.$attrs$=$.$attrs$||{},c.$attrsToReflect$.forEach(([h,d])=>{g.serializer&&e.$serializerValues$.has(h)?$.$attrs$[d]=e.$serializerValues$.get(h):$.$attrs$[d]=o[h]})),s&&$.$attrs$)for(const h of Object.keys($.$attrs$))o.hasAttribute(h)&&!["key","ref","style","class"].includes(h)&&($.$attrs$[h]=o[h]);$.$tag$=null,$.$flags$|=4,e.$vnode$=$,$.$elm$=f.$elm$=o.shadowRoot||o,C=o["s-sc"],J=!!(c.$flags$&1)&&!(c.$flags$&128),W=o["s-cr"],I=!1,A(f,$,s);{if(S.$flags$|=1,re){Oe($.$elm$);for(const h of m){const d=h.$nodeToRelocate$;if(!d["s-ol"]&&p.document){const v=p.document.createTextNode("");v["s-nr"]=d,x(d.parentNode,d["s-ol"]=v,d)}}for(const h of m){const d=h.$nodeToRelocate$,v=h.$slotRefNode$;if(v){const y=v.parentNode;let b=v.nextSibling;{let L=(r=d["s-ol"])==null?void 0:r.previousSibling;for(;L;){let _=(n=L["s-nr"])!=null?n:null;if(_&&_["s-sn"]===d["s-sn"]&&y===(_.__parentNode||_.parentNode)){for(_=_.nextSibling;_===d||_?.["s-sr"];)_=_?.nextSibling;if(!_||!_["s-nr"]){b=_;break}}L=L.previousSibling}}const E=d.__parentNode||d.parentNode,T=d.__nextSibling||d.nextSibling;(!b&&y!==E||T!==b)&&d!==b&&(!d["s-hn"]&&d["s-ol"]&&(d["s-hn"]=d["s-ol"].parentNode.nodeName),x(y,d,b),d.nodeType===1&&d.tagName!=="SLOT-FB"&&(d.hidden=(i=d["s-ih"])!=null?i:!1)),d&&typeof v["s-rf"]=="function"&&v["s-rf"](v)}else d.nodeType===1&&(s&&(d["s-ih"]=(a=d.hidden)!=null?a:!1),d.hidden=!0)}}I&&ke($.$elm$),S.$flags$&=-2,m.length=0}if(g.experimentalScopedSlotChanges&&c.$flags$&2){const h=$.$elm$.__childNodes||$.$elm$.childNodes;for(const d of h)d["s-hn"]!==H&&!d["s-sh"]&&(s&&d["s-ih"]==null&&(d["s-ih"]=(l=d.hidden)!=null?l:!1),d.hidden=!0)}W=void 0},Re=(e,t)=>{if(t&&!e.$onRenderResolve$&&t["s-p"]){const s=t["s-p"].push(new Promise(r=>e.$onRenderResolve$=()=>{t["s-p"].splice(s-1,1),r()}))}},ne=(e,t)=>{if(e.$flags$|=16,e.$flags$&4){e.$flags$|=512;return}Re(e,e.$ancestorComponent$);const s=()=>yt(e,t);if(t){queueMicrotask(()=>{s()});return}return Qe(s)},yt=(e,t)=>{const s=e.$hostElement$,r=z("scheduleUpdate",e.$cmpMeta$.$tagName$),n=s;if(!n)throw new Error(`Can't render component <${s.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let i;return t?i=w(n,"componentWillLoad",void 0,s):i=w(n,"componentWillUpdate",void 0,s),i=pe(i,()=>w(n,"componentWillRender",void 0,s)),r(),pe(i,()=>_t(e,n,t))},pe=(e,t)=>St(e)?e.then(t).catch(s=>{console.error(s),t()}):t(),St=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",_t=async(e,t,s)=>{var r;const n=e.$hostElement$,i=z("update",e.$cmpMeta$.$tagName$),a=n["s-rc"];s&&ot(e);const l=z("render",e.$cmpMeta$.$tagName$);kt(e,t,n,s),a&&(a.map(o=>o()),n["s-rc"]=void 0),l(),i();{const o=(r=n["s-p"])!=null?r:[],c=()=>bt(e);o.length===0?c():(Promise.all(o).then(c),e.$flags$|=4,o.length=0)}},ge=null,kt=(e,t,s,r)=>{try{ge=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,(g.hasRenderFn||g.reflect)&&(g.vdomRender||g.reflect)&&(g.hydrateServerSide||vt(e,t,r))}catch(o){D(o,e.$hostElement$)}return ge=null,null},bt=e=>{const t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,r=z("postUpdate",t),n=s,i=e.$ancestorComponent$;w(n,"componentDidRender",void 0,s),e.$flags$&64?(w(n,"componentDidUpdate",void 0,s),r()):(e.$flags$|=64,Et(s),w(n,"componentDidLoad",void 0,s),r(),e.$onReadyResolve$(s),i||mt()),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&V(()=>ne(e,!1)),e.$flags$&=-517},mt=e=>{V(()=>ut(p,"appload",{detail:{namespace:je}}))},w=(e,t,s,r)=>{if(e&&e[t])try{return e[t](s)}catch(n){D(n,r)}},Et=e=>{var t;return e.classList.add((t=g.hydratedSelectorName)!=null?t:"hydrated")},xt=(e,t)=>O(e).$instanceValues$.get(t),ve=(e,t,s,r)=>{const n=O(e);if(!n||g.serializer&&n.$serializerValues$.has(t)&&n.$serializerValues$.get(t)===s)return;const i=e,a=n.$instanceValues$.get(t),l=n.$flags$,o=i;s=Ee(s,r.$members$[t][0]);const c=Number.isNaN(a)&&Number.isNaN(s);if(s!==a&&!c){if(n.$instanceValues$.set(t,s),g.serializer&&g.reflect&&r.$attrsToReflect$&&o&&r.$serializers$&&r.$serializers$[t]){let u=s;for(const $ of r.$serializers$[t])u=o[$](u,t);n.$serializerValues$.set(t,u)}{if(r.$watchers$&&l&128){const u=r.$watchers$[t];u&&u.map($=>{try{o[$](s,a,t)}catch(h){D(h,i)}})}if((l&18)===2){if(o.componentShouldUpdate&&o.componentShouldUpdate(s,a,t)===!1)return;ne(n,!1)}}}},Tt=(e,t,s)=>{var r,n;const i=e.prototype;if(t.$members$||g.propChangeCallback){e.watchers&&!t.$watchers$&&(t.$watchers$=e.watchers),e.deserializers&&!t.$deserializers$&&(t.$deserializers$=e.deserializers),e.serializers&&!t.$serializers$&&(t.$serializers$=e.serializers);const a=Object.entries((r=t.$members$)!=null?r:{});a.map(([l,[o]])=>{if(o&31||o&32){const{get:c,set:f}=Object.getOwnPropertyDescriptor(i,l)||{};c&&(t.$members$[l][0]|=2048),f&&(t.$members$[l][0]|=4096),Object.defineProperty(i,l,{get(){return c?c.apply(this):xt(this,l)},configurable:!0,enumerable:!0}),Object.defineProperty(i,l,{set(u){const $=O(this);if($){if(f){typeof(o&32?this[l]:$.$hostElement$[l])>"u"&&$.$instanceValues$.get(l)&&(u=$.$instanceValues$.get(l)),f.apply(this,[Ee(u,o)]),u=o&32?this[l]:$.$hostElement$[l],ve(this,l,u,t);return}{ve(this,l,u,t);return}}}})}});{const l=new Map;i.attributeChangedCallback=function(o,c,f){S.jmp(()=>{var u;const $=l.get(o),h=O(this);if(g.serializer&&h.$serializerValues$.has($)&&h.$serializerValues$.get($)===f)return;if(this.hasOwnProperty($)&&g.lazyLoad,g.deserializer&&t.$deserializers$&&t.$deserializers$[$]){const y=(b,E)=>{const T=E?.[b](f,$);T!==this[$]&&(this[$]=T)};for(const b of t.$deserializers$[$])y(b,this);return}else{if(i.hasOwnProperty($)&&typeof this[$]=="number"&&this[$]==f)return;if($==null){const y=h?.$flags$;if(h&&y&&!(y&8)&&y&128&&f!==c){const E=this,T=(u=t.$watchers$)==null?void 0:u[o];T?.forEach(L=>{E[L]!=null&&E[L].call(E,f,c,o)})}return}}const d=a.find(([y])=>y===$);d&&d[1][0]&4&&(f=!(f===null||f==="false"));const v=Object.getOwnPropertyDescriptor(i,$);f!=this[$]&&(!v.get||v.set)&&(this[$]=f)})},e.observedAttributes=Array.from(new Set([...Object.keys((n=t.$watchers$)!=null?n:{}),...a.filter(([o,c])=>c[0]&31).map(([o,c])=>{var f;const u=c[1]||o;return l.set(u,o),c[0]&512&&((f=t.$attrsToReflect$)==null||f.push([o,u])),u})]))}}return e},Lt=async(e,t,s,r)=>{let n;if((t.$flags$&32)===0){t.$flags$|=32,s.$lazyBundleId$;{n=e.constructor;const l=e.localName;customElements.whenDefined(l).then(()=>t.$flags$|=128)}if(n&&n.style){let l;typeof n.style=="string"?l=n.style:typeof n.style!="string"&&(t.$modeName$=dt(e),t.$modeName$&&(l=n.style[t.$modeName$]));const o=me(s,t.$modeName$);if(!B.has(o)){const c=z("registerStyles",s.$tagName$);it(o,l,!!(s.$flags$&1)),c()}}}const i=t.$ancestorComponent$,a=()=>ne(t,!0);i&&i["s-rc"]?i["s-rc"].push(a):a()},ye=(e,t)=>{},Ot=e=>{if((S.$flags$&1)===0){const t=O(e);if(!t)return;const s=t.$cmpMeta$,r=z("connectedCallback",s.$tagName$);if(t.$flags$&1)we(e,t,s.$listeners$),t?.$lazyInstance$?ye(t.$lazyInstance$):t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>ye(t.$lazyInstance$));else{t.$flags$|=1,s.$flags$&12&&zt(e);{let n=e;for(;n=n.parentNode||n.host;)if(n["s-p"]){Re(t,t.$ancestorComponent$=n);break}}s.$members$&&Object.entries(s.$members$).map(([n,[i]])=>{if(i&31&&n in e&&e[n]!==Object.prototype[n]){const a=e[n];delete e[n],e[n]=a}}),Lt(e,t,s)}r()}},zt=e=>{if(!p.document)return;const t=e["s-cr"]=p.document.createComment("");t["s-cn"]=!0,x(e,t,e.firstChild)},At=async e=>{if((S.$flags$&1)===0){const t=O(e);t?.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0)}R.has(e)&&R.delete(e),e.shadowRoot&&R.has(e.shadowRoot)&&R.delete(e.shadowRoot)},Rt=(e,t)=>{const s={$flags$:t[0],$tagName$:t[1]};s.$members$=t[2],s.$listeners$=t[3],s.$watchers$=e.$watchers$,s.$deserializers$=e.$deserializers$,s.$serializers$=e.$serializers$,s.$attrsToReflect$=[],!(s.$flags$&1)&&s.$flags$&256;const r=e.prototype.connectedCallback,n=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__hasHostListenerAttached:!1,__registerHost(){Be(this,s)},connectedCallback(){if(!this.__hasHostListenerAttached){const i=O(this);if(!i)return;we(this,i,s.$listeners$),this.__hasHostListenerAttached=!0}Ot(this),r&&r.call(this)},disconnectedCallback(){At(this),n&&n.call(this)},__attachShadow(){if(!this.shadowRoot)tt.call(this,s);else if(this.shadowRoot.mode!=="open")throw new Error(`Unable to re-use existing shadow root for ${s.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`)}}),e.is=s.$tagName$,Tt(e,s)},we=(e,t,s,r)=>{s&&p.document&&s.map(([n,i,a])=>{const l=jt(p.document,e,n),o=wt(t,a),c=Ht(n);S.ael(l,i,o,c),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>S.rel(l,i,o,c))})},wt=(e,t)=>s=>{var r;try{g.lazyLoad||e.$hostElement$[t](s)}catch(n){D(n,e.$hostElement$)}},jt=(e,t,s)=>s&4?e:s&8?p:s&16?e.body:t,Ht=e=>Ie?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0;const Pt=Rt(class extends We{constructor(){super(),this.__registerHost(),this.email=void 0,this.tel=void 0,this.sms=void 0,this.facetime=void 0,this.href=void 0,this.headers=void 0,this.decoder=t=>window.atob(t),this.human=!1}connectedCallback(){this.innerEl=this.host.innerHTML,this.host.innerHTML=""}handleFocus(){this.human=!0}handleMouseOver(){this.human=!0}handleContextMenu(){this.human=!0}handleClick(){this.human=!0}generateLink(){let t="",s="";const r=n=>Object.keys(n).map(i=>`${i}=${encodeURIComponent(n[i])}`).join("&");return this.email?(s=this.decoder(this.email),t=`mailto:${s}`,this.headers&&(t+=`?${r(this.headers)}`)):this.tel?(s=this.decoder(this.tel),t=`tel:${s}`):this.sms?(s=this.decoder(this.sms),t=`sms:${s}`):this.facetime?(s=this.decoder(this.facetime),t=`facetime:${s}`):this.href&&(s=this.decoder(this.href),t=s),this.innerEl&&(s=this.innerEl),M("a",{href:t},s)}render(){return this.human?this.generateLink():M("span",null,"Not for the bots")}get host(){return this}},[0,"obfuscate-link",{email:[1],tel:[1],sms:[1],facetime:[1],href:[1],headers:[16],decoder:[16],human:[32]},[[8,"focus","handleFocus"],[9,"mouseover","handleMouseOver"],[8,"contextmenu","handleContextMenu"],[0,"click","handleClick"]]]);customElements.define("obfuscate-link",Pt);
